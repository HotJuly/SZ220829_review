# Vue组件通信方式总结

1. ## props

   1. 使用场景:父子组件通信
   2. 父向子传
      1. 父组件在子组件的标签上,**添加标签属性**,并将需要传递的数据放在标签属性值中
      2. 子组件想要接收数据,需要**在配置对象中,添加props配置选项**,来声明想要接收哪些数据
      3. 子组件即可将接收到的数据,当作自己的数据使用,但是不允许修改
      4. **总结:父传子,父亲传的是数据本身**
   3. 子向父传
      1. 父组件在子组件的标签上,**添加标签属性**,并将需要传递的函数放在标签属性值中
      2. 子组件想要接收数据,需要**在配置对象中,添加props配置选项**,来声明想要接收哪些数据
      3. 子组件调用接收到的函数,并向内部传入实参
      4. 最终执行函数的代码,会修改父组件的状态数据,实现子向父传参
         1. **注意:传下来的函数,必须在methods中,声明,因为methods的函数this都会被使用bind强行改成父组件的组件实例对象**
      5. **总结:子传父,父亲传的是用来接收数据的函数**

2. ## provide/inject

   1. 使用场景:祖孙组件之间
   2. 暴露数据
      1. 祖先组件在自己的配置对象中,添加provide属性,属性值类型为对象,可以将需要暴露的数据以属性名和属性值的格式,写在provide对象即可
   3. 获取数据
      1. 后代组件在自己的配置对象中,添加inject属性,属性值类型string[ ],可以接收到指定属性名的数据
   4. 注意:
      1. provide暴露的数据,本身是非响应式的,如果想要有响应式效果,需要自己处理该数据
      2. provide如果使用函数写法,就可以读取data中的数据,来向外暴露,可以实现数据的灵活性
      3. 如果想让provide暴露的数据是响应式的,可以将对象放在data中先处理之后,在用provide暴露

3. ## 自定义事件

   1. ### 面试题:区分原生事件和自定义事件

      1. ### 原生事件:其实就是一阶段所学的DOM事件

         1. ### 原生DOM事件的事件名都是由W3C机构制定的

      2. ### 自定义事件:其实是Vue专门给组件通信提供的新型事件

         1. ### 自定义事件的事件名是由开发者自己制定的

   2. ### 面试题2:如何区分一个事件是原生事件还是自定义事件?

      1. ### 如果事件是绑定在原生DOM标签上的,那么一定是原生事件

      2. ### 如果事件是绑定在组件标签上的,那么一定是自定义事件

         1. ### 原因:因为组件标签浏览器不认识,最终显示在页面上的,其实是组件内部的template内容

         2. ### 可以在绑定自定义事件的时候,加上修饰符.native,就可以将该事件转为原生事件,并绑定在当前组件的根节点上

   3. v-model指令(双向数据绑定)

      1. 对input标签使用

         1. 将data中的状态数据,作为默认值,显示在input框中(**属性名value**)

         2. 当用户修改input框的数据时,会自动修改data中对应的状态属性(**事件名是input**)

         3. ```html
            <input type="text" :value="msg" @input="msg=$event.target.value">
            ```

      2. 对组件标签使用

         1. 将data中的状态数据,作为标签属性传给子组件(**默认属性名value**)

            1. 同时还会给子组件绑定一个自定义事件(**默认事件名input**)

         2. 子组件可以通过自定义事件,来修改父组件的数据

         3. ```html
            <HelloWorld :value="msg" @input="(data)=>msg=data"/>
            ```

         4. 注意:**默认属性名和事件名都是可以通过model属性进行配置修改的**

4. ## 找到对应组件实例对象

   1. $parent->找到当前组件的父组件实例对象
   2. $root->找到当前组件树的根组件实例对象
   3. $children->获取当前所有子组件组成的数组
      1. 该数组不具有响应式效果,修改内部对象的排列顺序,不会影响到页面上的展示顺序
      2. 该数组并不能保证排列顺序和书写顺序一致,因为有可能子组件使用到了组件懒加载写法
         1. 反过来说,只要子组件没有使用组件懒加载,那么当前children的顺序和书写顺序是一致的
   4. **$refs->获取到template中,某个标签的原生DOM或者组件实例**
      1. **如果使用ref标记一个原生DOM标签,那么等下读取到的就是生成DOM节点**
      2. **如果使用ref标记一个组件标签,那么读取到的就是他的组件实例对象**

5. attrs和listener

   1. $attrs->他会收集当前组件,没有被props接收的标签属性
      1. 相当于他就是props的垃圾桶
      2. 他的数据类型是对象
      3. 他会将标签属性的属性名作为自己的属性名
         1. 他会将标签属性的属性值作为自己的属性值
   2. $listeners->他会收集当前组件身上,所有的自定义事件
      1. 他的数据类型是对象
      2. 他会将自定义事件的名称,作为自己的属性名
         1. 将回调函数,作为自己的属性值
   3. 扩展:
      1. v-bind指令
         1. 如果传一个对象给他,那么他会将该对象解构展开,对象中所有的属性名都会成为标签属性名,所有的属性值都会成为对应标签属性的属性值
         2. 它可以配合$attrs,实现父组件传下来的数据,给后代组件使用的效果
      2. v-on指令
         1. 如果传一个对象给他,那么他会将该对象解构处理,并将对象中的属性名作为事件名称,属性值作为时间回调函数进行绑定
         2. 它可以配合$listeners,实现父组件传下来的事件,给后代组件绑定的效果