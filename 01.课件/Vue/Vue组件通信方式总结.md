# Vue组件通信方式总结

1. ## props

   1. 使用场景:父子组件通信
   2. 父向子传
      1. 父组件在子组件的标签上,**添加标签属性**,并将需要传递的数据放在标签属性值中
      2. 子组件想要接收数据,需要**在配置对象中,添加props配置选项**,来声明想要接收哪些数据
      3. 子组件即可将接收到的数据,当作自己的数据使用,但是不允许修改
      4. **总结:父传子,父亲传的是数据本身**
   3. 子向父传
      1. 父组件在子组件的标签上,**添加标签属性**,并将需要传递的函数放在标签属性值中
      2. 子组件想要接收数据,需要**在配置对象中,添加props配置选项**,来声明想要接收哪些数据
      3. 子组件调用接收到的函数,并向内部传入实参
      4. 最终执行函数的代码,会修改父组件的状态数据,实现子向父传参
         1. **注意:传下来的函数,必须在methods中,声明,因为methods的函数this都会被使用bind强行改成父组件的组件实例对象**
      5. **总结:子传父,父亲传的是用来接收数据的函数**

2. ## provide/inject

   1. 使用场景:祖孙组件之间
   2. 暴露数据
      1. 祖先组件在自己的配置对象中,添加provide属性,属性值类型为对象,可以将需要暴露的数据以属性名和属性值的格式,写在provide对象即可
   3. 获取数据
      1. 后代组件在自己的配置对象中,添加inject属性,属性值类型string[ ],可以接收到指定属性名的数据
   4. 注意:
      1. provide暴露的数据,本身是非响应式的,如果想要有响应式效果,需要自己处理该数据
      2. provide如果使用函数写法,就可以读取data中的数据,来向外暴露,可以实现数据的灵活性
      3. 如果想让provide暴露的数据是响应式的,可以将对象放在data中先处理之后,在用provide暴露

3. ## 自定义事件

   1. ### 使用场景:子向父传参

   2. ### 面试题:区分原生事件和自定义事件

      1. #### 原生事件:其实就是一阶段所学的DOM事件

         1. #### 原生DOM事件的事件名都是由W3C机构制定的

      2. #### 自定义事件:其实是Vue专门给组件通信提供的新型事件

         1. #### 自定义事件的事件名是由开发者自己制定的

   3. ### 面试题2:如何区分一个事件是原生事件还是自定义事件?

      1. #### 如果事件是绑定在原生DOM标签上的,那么一定是原生事件

      2. #### 如果事件是绑定在组件标签上的,那么一定是自定义事件

         1. #### 原因:因为组件标签浏览器不认识,最终显示在页面上的,其实是组件内部的template内容

         2. #### 可以在绑定自定义事件的时候,加上修饰符.native,就可以将该事件转为原生事件,并绑定在当前组件的根节点上

   4. 四个基础API

      1. $on->可以给某个组件实例,绑定自定义事件以及事件处理器
      2. $once->可以给某个组件实例,绑定自定义事件以及事件处理器,但是这个事件只能触发一次
         1. 触发一次之后,会自动解绑
      3. $emit->可以触发某个组件实例身上的某类事件
      4. $off->可以移除某个实例对象身上的事件
         1. 如果没有传入任何参数,就代表移除当前实例对象上所有的事件
         2. 如果只传入一个参数,就代表移除当前实例对象上对应类型的事件,以及他所有的事件处理器
         3. 如果传入两个参数,就代表溢出当前实例对象上对应类型事件中,对应的事件处理器

   5. v-model指令(双向数据绑定)

      1. 对input标签使用

         1. 将data中的状态数据,作为默认值,显示在input框中(**属性名value**)

         2. 当用户修改input框的数据时,会自动修改data中对应的状态属性(**事件名是input**)

         3. ```html
            <input type="text" :value="msg" @input="msg=$event.target.value">
            ```

      2. 对组件标签使用

         1. 将data中的状态数据,作为标签属性传给子组件(**默认属性名value**)

            1. 同时还会给子组件绑定一个自定义事件(**默认事件名input**)

         2. 子组件可以通过自定义事件,来修改父组件的数据

         3. ```html
            <HelloWorld :value="msg" @input="(data)=>msg=data"/>
            ```

         4. 注意:**默认属性名和事件名都是可以通过model属性进行配置修改的**

   6. .sync修饰符

      1. 通过标签属性的形式,将数据传递给子组件使用(标签属性名自定义)
      2. 子组件中,声明props,来接收父组件传下来的数据
      3. 子组件可以通过触发自定义事件,来修改父组件的数据(事件名: update:属性名)
      4. **注意:在Vue3中.v-model和sync修饰符二合一了,最终语法使用的是v-model的语法,事件名使用的是sync的事件名**

   7. 全局事件总线

      1. 角色

         1. 订阅者->想要接收数据的人
         2. 发布者->有数据的人(想要发送数据的人)

      2. 操作

         1. 订阅
         2. 发布
         3. 取消订阅

      3. 约束

         1. 订阅者和发布者必须同时存在
         2. 订阅操作必须在发布之前

      4. 流程:

         1. 创建一个Vue实例对象,将其保存在Vue的原型对象上,以$bus属性进行保存

            1. ```javascript
               Vue.prototype.$bus = new Vue();
               ```

         2. 在订阅者的代码中,使用$on去绑定全局事件监听

            1. ```
               this.$bus.$on('abc',(data)=>{
                     console.log('abc',data)
                   })
               ```

         3. 在发布者的代码中,使用$emit去触发全局事件监听

            1. ```
               this.$bus.$emit('abc',this.msg)
               ```

            注意:$bus中,必须存放一个Vue的实例对象,否则后续使用on和emit会报错

4. ## 找到对应组件实例对象

   1. $parent->找到当前组件的父组件实例对象
   2. $root->找到当前组件树的根组件实例对象
   3. $children->获取当前所有子组件组成的数组
      1. 该数组不具有响应式效果,修改内部对象的排列顺序,不会影响到页面上的展示顺序
      2. 该数组并不能保证排列顺序和书写顺序一致,因为有可能子组件使用到了组件懒加载写法
         1. 反过来说,只要子组件没有使用组件懒加载,那么当前children的顺序和书写顺序是一致的
   4. **$refs->获取到template中,某个标签的原生DOM或者组件实例**
      1. **如果使用ref标记一个原生DOM标签,那么等下读取到的就是生成DOM节点**
      2. **如果使用ref标记一个组件标签,那么读取到的就是他的组件实例对象**

5. ## attrs和listeners

   1. $attrs->他会收集当前组件,没有被props接收的标签属性
      1. 相当于他就是props的垃圾桶
      2. 他的数据类型是对象
      3. 他会将标签属性的属性名作为自己的属性名
         1. 他会将标签属性的属性值作为自己的属性值
   2. $listeners->他会收集当前组件身上,所有的自定义事件
      1. 他的数据类型是对象
      2. 他会将自定义事件的名称,作为自己的属性名
         1. 将回调函数,作为自己的属性值
   3. 扩展:
      1. v-bind指令
         1. 如果传一个对象给他,那么他会将该对象解构展开,对象中所有的属性名都会成为标签属性名,所有的属性值都会成为对应标签属性的属性值
         2. 它可以配合$attrs,实现父组件传下来的数据,给后代组件使用的效果
      2. v-on指令
         1. 如果传一个对象给他,那么他会将该对象解构处理,并将对象中的属性名作为事件名称,属性值作为时间回调函数进行绑定
         2. 它可以配合$listeners,实现父组件传下来的事件,给后代组件绑定的效果

6. ## 插槽

   1. 使用场景:如果你想要自定义子组件中的结构,就可以使用插槽
   2. 一共分为3种,他们的都可以传递一段结构
   3. 默认插槽
      1. 父组件在子组件的成对标签中,写入一段页面结构
         1. 结构是在父组件里面写的,但是会在子组件里面显示
      2. 子组件在自己的template中,使用slot组件,来显示传下来的插槽结构
   4. 具名插槽
      1. 父组件在子组件的成对标签中,写入一段页面结构
         1. 父组件可以给插槽结构,使用v-slot指令取一个别名
      2. 子组件在自己的template中,使用slot组件,来显示传下来的插槽结构
         1. 由于插槽已经具有别名,所以需要给slot组件,添加上name属性,输入对应的别名
      3. 扩展:个人认为,默认插槽其实就是名称为default的具名插槽
   5. 作用域插槽
      1. 父组件在子组件的成对标签中,写入一段页面结构
         1. 父组件可以给插槽结构,使用v-slot指令取一个别名
      2. 子组件在自己的template中,使用slot组件,来显示传下来的插槽结构
         1. 由于插槽已经具有别名,所以需要给slot组件,添加上name属性,输入对应的别名
      3. 子组件将需要使用到的数据,通过标签属性的形式,传给slot组件
      4. 插槽可以在#footer之后,添加="变量名",即可获取到子组件传递的数据,配合插值语法,来显示传递的数据
   6. **以上三种插槽,都只有父传子,没有子传父!!!**

7. VueRouter中的路由传参

8. Vuex