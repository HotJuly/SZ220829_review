# VueRouter

1. VueRouter是什么?

   1. 他是一个npm包
   2. 他是Vue的可扩展插件(可以使用Vue.use)
   3. 它可以实现单页面应用(SPA)
      1. 问题:请问什么是单页面应用?
         1. 一个html文件就是一个页面,整个项目中,只有一个html文件,就是单页面项目
            1. 内部会使用DOM的CRUD方法,对html中的内容进行修改操作,实现一个html文件,显示多种页面的感觉
      2. 问题:请问不使用VueRouter,能否实现单页面应用?
         1. 可以,甚至不使用框架,也可以实现单页面应用
         2. 虽然使用js或者jq等东西,也能实现单页面应用,但是由于需要操作的DOM节点太多了,所以很难去做
      3. 问题:请问大家是否做过多页面应用?
         1. 例如:尚品汇/大疆官网
         2. 多页面应用其实就是说,一个项目中,具有很多个html文件,对于这些文件之前的切换跳转,是使用a标签实现的

2. VueRouter提供给我们什么东西? 

   1. 构造函数
      1. 通过暴露的构造函数,可以创建一个路由器实例对象
   2. 全局组件
      1. router-view
         1. 该组件会根据当前路由地址的变化,显示对应的路由组件
         2. **原理:其实router-view组件中,使用到了响应式原理**
            1. **只要路径数据发生了变化,router-view就会自动更新,展示最新的内容**
      2. router-link
         1. 默认生成一个a标签,用户点击a标签,就会发生路由跳转
         2. **声明式导航的定义:通过标签的形式,引导用户进行跳转**
         3. **原理:**
            1. **默认生成一个a标签**
            2. **然后给该标签绑定点击事件**
            3. **在事件回调函数中,禁用浏览器的默认行为,并且调用编程式导航实现路由跳转**
   3. 公共对象
      1. $router
         1. 这是一个路由器对象,它是用来管理路由的
         2. 他会给开发者提供一些操作路由的API,例如:push,replace,go,back等
         3. push方法
            1. 该方法可以控制路由的跳转,并且是在真正的控制浏览器的历史记录栈
            2. **push方法会保留上一个历史记录,也就是说可以回退到上个路由**
            3. **项目中,绝大多数的路由跳转都是这类**
            4. **编程式导航的定义:通过调用js的API,来强行控制用户的跳转**
            5. **原理:**
               1. **hash模式下,其实是使用了location.assign(路径),来控制页面的路由的跳转**
               2. **history模式下,其实是使用了history.pushState({},"",路径),来控制页面的路由跳转**
         4. replace方法
            1. 该方法可以控制路由的跳转,并且是在真正的控制浏览器的历史记录栈
            2. **replace方法不会保留上个历史记录,会对其进行覆盖处理,也就是说无法回到上个路由**
            3. **项目中,少部分场景会使用到该方法,例如:login页面,order页面,pay页面等****
            4. **原理:**
               1. **hash模式下,其实是使用了location.replace(路径),来控制页面的路由的跳转**
               2. **history模式下,其实是使用了history.replaceState({},"",路径),来控制页面的路由跳转**
      2. $route
         1. 这是一个路由对象,它用于记录当前路由的重要信息
         2. 他会给开发者提供一些当前路由的参数信息
         3. fullpath属性
            1. 存储这当前路由的完整地址
         4. query
            1. 他是URL传参的一员
            2. 语法:"/home?userId=100"
            3. 可以将参数拼接在路径中进行传递
         5. params
            1. 他也是URL传参的一员
            2. 语法:"/home/100"
            3. 可以将参数拼接在路径中进行传递
            4. 想使用这种传参方式,必须在声明路由对象的时候,在path中拼接占位符
               1. 例如:path:"/home/:id"
         6. meta
            1. 他不是URL传参的一员
            2. 该方案传递参数,需要在声明路由对象的时候进行添加
               1. 将需要传递的数据,写在与path,component属性同级的地方

3. 我们提供给VueRouter什么东西?

   1. 配置对象
      1. mode属性
         1. 属性值:"hash"||"history"
         2. hash
            1. 可以开启路由器的hash模式,路径中会出现#号
            2. **原理:**
               1. **通过给window对象绑定事件监听,来监视地址栏的变化**
                  1. **事件名称:hashchange**
               2. **在事件回调函数被触发之后,我们可以读取location对象的hash属性,获取到当前最新的路由地址**
               3. **然后将得到的路由地址,更新给响应式属性path,来导致对应组件更新,显示最新结果** 
            3. **优点:**
               1. **在浏览器眼里,#就是锚点,目前所有浏览器都支持锚点功能**
                  1. **所以兼容很好,兼容性IE6+**
               2. **hash模式在上线的过程中, 不需要做什么特殊配置**
            4. **缺点:**
               1. **丑就是原罪,路径中带有#**
               2. **由于hash路径会被当成锚点解析,就会导致真正的锚点无法正常使用**
         3. history
            1. 可以开启路由器的history模式,路径中只有/没有#
            2. **原理:**
               1. **通过给window对象绑定事件监听,来监视地址栏的变化**
                  1. **事件名称:popstate**
               2. **在事件回调函数被触发之后,我们可以读取location对象的pathname属性,获取到当前最新的路由地址**
               3. **然后将得到的路由地址,更新给响应式属性path,来导致对应组件更新,显示最新结果** 
            3. **优点:**
               1. **颜值就是正义,路径中没有#号**
               2. **锚点功能不受影响,可以正常使用**
            4. **缺点:**
               1. **兼容性较差,因为使用到的history对象是html5的新特性**
               2. **项目上线的时候,需要做特殊的上线配置,否则项目将会出现问题**
                  1. **问题:当用户在某个路由地址下,刷新当前页面,浏览器会将history路由地址,当作后端接口地址请求,后端服务器没有该接口,就会返回404,那么当前网页就会显示失败**
                  2. **解决方法:**
                     1. **用户在某个路由地址下刷新页面(地址:/home)**
                     2. **浏览器会将前端路由地址/home,发送给后端公司服务器**
                     3. **此时要求后端,自己没有的接口不要返回404,**
                        1. **而是将当前项目html文件,返回给浏览器**
                     4. **浏览器接收到当前项目的html文件,解析该文件**
                     5. **解析的过程中,发现需要请求一个js文件,又向后端服务器发送请求**
                     6. **后端将网页需要使用的js文件返回值后,浏览器会自动执行内部的代码**
                     7. **此时js文件中,VueRouter代码就会生效,开始自动获取到地址栏中的地址,**
                        1. **将/home地址作为前端路由进行解析,然后自动显示对应的路由组件**
      2. routes属性
         1. 数据类型:routeObj[ ]
         2. 路由对象中的重要属性
            1. path
               1. 声明当前路由的地址
            2. component
               1. 如果当前浏览器地址与path相同,需要显示的路由组件

4. 导航守卫(又称为路由守卫)

   1. 导航守卫的效果就是控制当前路由跳转是否成功

   2. 一共有三大类,7种导航守卫

   3. 全局守卫

      1. 全局前置守卫

         1. 他会在路由跳转之前触发
         2. 就比如说中国飞俄罗斯,需要在飞机起飞之前就检查签证,没有就不能起飞

      2. 全局解析守卫

         1. 在异步路由组件解析结束之后,开始执行

      3. 全局后置守卫

         1. 他会在路由跳转结束之后出发
         2. 就比如说中国飞菲律宾,需要在飞机到达之后才会检查签证

      4. ```javascript
         // 绑定位置是写在路由器对象身上
         router.beforeEach((to, from, next) => {
           //to->想去哪
           //from->从哪来
           //next->控制放行的函数
           //next()->想去哪就去哪
           //next(false)->从哪来回哪去
           //next('/login')或者next({path:"/login"})->带你去个好地方
         })
         ```

   4. 路由独享守卫

      1. 在进入当前路由之前会触发

      2. ```javascript
         const router = new VueRouter({
           routes: [
             {
               path: '/foo',
               component: Foo,
               beforeEnter: (to, from, next) => {
                 // ...
               }
             }
           ]
         })
         ```

   5. 组件内置守卫

      1. 组件进入守卫

         1. 进入组件之前触发

      2. 组件更新守卫

         1. 如果发生路由跳转之后,显示的路由组件还是同一个
            1. 说白了,路由组件被复用了,那么就会触发更新守卫

      3. 组件离开守卫

         1. 离开组件之前触发
         2. 所有的守卫中,只有这一个守卫可以监视离开这个操作

      4. ```javascript
         <script>
         export default {
           data(){
             return{
               msg:123
             }
           },
           beforeRouteEnter(to, from, next) {
             // 在渲染该组件的对应路由被 confirm 前调用
             // 不！能！获取组件实例 `this`
             // 因为当守卫执行前，组件实例还没被创建
           },
           beforeRouteUpdate(to, from, next) {
             // 在当前路由改变，但是该组件被复用时调用
             // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
             // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
             // 可以访问组件实例 `this`
           },
           beforeRouteLeave(to, from, next) {
             // 导航离开该组件的对应路由时调用
             // 可以访问组件实例 `this`
           }
         }
         </script>
         ```

         ​