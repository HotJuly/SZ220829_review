# 组件懒加载

1. 前沿:
   1. 正常一个项目以生产环境打包之后,会得到一个dist文件夹,内部具有文件:
      1. main.js
      2. index.html
      3. 扩展:
         1. 如果图片小于1MB,那么会被脚手架使用base64格式进行编译,变成一个base64字符串,写入当前js文件中
         2. 如果图片大于1MB,那么会被脚手架作为单独的图片文件进行输出
         3. CSS代码需要根据脚手架配置判断,有部分公司会作为单独的css文件输出,也有的公司会把他变成js字符串存储在js文件中
   2. 假设现在项目中,具有10个组件,每个组件的文件大小为1MB
      1. 那么main.js文件会有所有组件的代码,所以他的大小是10MB
      2. 假设用户的网速为1MB/s,那么用户想要看到页面,就必须等到js文件请求结束,那么就需要白屏10秒钟
2. ES6模块化语法
   1. 静态引入
      1. 语法:import Home from '@/components/Home.vue';
      2. 该语法在项目上线之后,会被编译消失,该语法会变成对应的依赖文件内容
      3. 所以如果项目中,全都使用该语法引入组件代码,那么整个项目的代码会合并成一个js文件
   2. 动态引入
      1. 语法:import('@/components/Home.vue')
      2. 该语法在项目上线之后,依旧存在,不会消失
      3. webpack在编译到该语法的时候,他会将该语法引入的文件作为单独的js文件进行输出
3. 使用组件懒加载之后
   1. 我们使用组件懒加载方法,来引入当前项目中所有的组件
      1. 那么现在main.js中,就只会拥有首页的代码,而其余9个组件的代码,会单独切割为9个js文件存储
         1. 所以main.js文件的大小是1MB,而其余9个js文件也各为1MB
      2. 此时用户想要查看首页,那么服务器就会返回首页对应的js文件,大小为1MB,所以只需要1秒钟就可以下载完毕,那么用户就可以看到首页的内容
   2. **好处:由于main.js文件体积变小,所以占用的带宽减少,请求时间变短,解析代码时间也变短,最终导致页面首屏渲染速度变快,白屏时间变短**
   3. **坏处:由于main.js中只存有首页的代码,那么后续组件显示切换的速度就会变慢**
      1. **因为后续组件的代码都在服务器上,想要看到这些组件,需要额外发送请求,请求对应的js文件,返回值后解析代码,才能显示**
      2. **也就是说,后续页面的首次显示,都需要等待网络请求的时间**
4. **组件预加载**
   1. **当用户看到首页的内容之后,CPU空闲的情况下,趁用户不注意的时候,偷偷的请求未来可能要用到的组件代码**
   2. **好处:可以解决懒加载的后续页面显示速度较慢的问题,可以提前请求会对应的文件,让后面使用的时候,不需要再等待网络请求的时间**
   3. **坏处:会比较浪费流量**
   4. **原理:**
      1. **通过window.onload事件监视页面资源的加载是否已经结束**
      2. **如果load事件的回调函数触发了,创建一个script标签,填写src属性**
      3. **那么script标签就会自动发送请求,请求服务器上对应的js文件**
      4. **最终将请求会的文件代码,存储于内存中并自动解析**