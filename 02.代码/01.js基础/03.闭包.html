<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
    /*
        闭包
            1.闭包的产生条件
                1.必须具有内外函数嵌套
                2.内部函数使用外部函数的变量(标识)

                问题:请问内部函数如果没有return出去,会不会产生闭包
                回答:无论内部函数是否有暴露给外界使用,都会产生闭包
                    个人认为,闭包分为两种
                        有效闭包
                            如果外部函数有将内部函数暴露出去给外界使用,这个闭包就是有效闭包

                        无效闭包
                            如果外部函数没有将内部函数暴露出去给外界使用,这个闭包就是无效闭包

            2.闭包的产生时机
                外部函数被调用的时候,就会产生闭包

            3.闭包的优点
                延长局部变量生命周期
                    问题:什么叫延长?
                    理解:本来只能存在一段时间,可以将改时间变长

                    问题:一个变量到底能存活多久?
                    回答:在函数调用结束的时候,本次的执行上下文就会被销毁,
                        那么存在执行上下文中的变量对象也会随之销毁,
                        最终导致变量对象中的变量以及变量值也销毁

                    问题:如何延长了变量的生命周期
                        由于外部函数将内部函数暴露出去给外界使用,那么垃圾回收机制就不会回收这个内部函数,
                        同时本该在外部函数调用结束之后就要销毁的变量,由于这个内部函数还需要使用这个变量,
                        所以js引擎会所使用闭包将需要用到的变量,全部缓存起来,留作以后使用

                可以实现js模块化
    */

    /*
        栈结构
        数据类型:数组
        特点:先进后出,后进先出
        

        队列结构
        数据类型:数组
        特点:先进先出,后进后出

        执行栈中,存放的是函数的执行上下文

        执行上下文
            执行上下文,其实包含了当前函数的this指向,return结果,以及一个变量对象
            变量对象:他会收集当前函数中,所有的变量以及变量值
                变量名会成为变量对象的属性名
                变量值会成为变量对象的属性值

                扩展:其实函数使用变量,他的查找过程,不是向前看这么简单,
                        他会先从自己的变量对象上找同名属性,如果没有会找到父级函数的变量对象,以此类推
                        如果最终,找到全局window身上还没有,那么就会报错

                        其实window就是最大的一个变量对象

            创建时机
                每次调用函数的时候,都会创建一个全新的执行上下文,
                    并且自动放入执行栈中(这个过程称为入栈)

            销毁时机
                函数代码执行结束的时候,就会将对应的执行上下文从执行栈中弹出,并销毁
                这个过程称为出栈
    */

    function wrap(){
        var a = 1;

        function inner(){
            console.log('inner',a)
        }

        // console.log(inner)
        // window.fn = inner;
        return inner;
    }

    var fn = wrap();
    // fn();
    console.log(fn)

    //-------------------------------
    // 面试就说,这种代码不会产生闭包
    // var a = 1;
    // function wrap(){
    //     console.log(a)
    // }
    // wrap();

    //------------------------------------
    // function fn(){
    //     var a = 1;
    //     a++;
    //     console.log(a);
    // }

    // fn();
    // fn();
    // fn();
    // fn();

    //------------------------------------
    // var a = 1;
    // function fn(){
    //     function inner(){
    //         console.log(a)
    //     }
    //     var a = 2;
    //     inner();
    // }

    // fn();

    </script>
  </body>
</html>
